Den Anforderungen der Entwicklung entsprechend wurde zunächst entschieden, welche Technologien zum Einsatz kommen. 

\subsection{Anwendungsframework}
Bei der Auswahl des Framework zur Programmierung der eigentlichen Anwendung gibt es, wie in Kapitel \ref{sec:mobile_development} erläutert, eine Vielzahl von möglichen Herangehensweisen.
Die Anwendung ist letztendlich der Teil unseres Systems, welches direkt mit dem Nutzer in Berührung kommt.
Daher sind vor allem die Anforderungen an Performance, Aussehen und Benutzbarkeit der Oberfläche essentiell wichtig.
Gleichzeitig ist bei der Entwicklung auf die verwendete Programmiersprache, die Entwicklungsumgebung, welche das Framework mit sich bringt und die Kenntnisse aller Entwickler zu achten.\\
\\
Wie bereits in Abbildung \ref{fig:crossplattform_popularity} gezeigt, können sich Marktanteile verschiedener Frameworks sehr schnell ändern. 
Dies hängt auch deutlich mit den unterliegenden Plattformen und deren Update-Zyklen zusammen.
Google beispielsweise veröffentlicht beinahe jährlich eine neue Version von Android\footnote{\href{https://engineerbabu.com/blog/evolution-of-android-versions/}{engineerbabu.com}}, weshalb sich eben Programmierumgebungen immer mitentwickeln.
Die Popularität eines Frameworks spiegelt somit unter anderem wieder, wie gut es mit den neuesten Features und Programmierkonzepten umgeht. 
Daher wurde sich bei den plattformübergreifenden Frameworks \ref{sec:framework_introduction} auf React Native und Flutter beschränkt. 
Beide bieten vordefinierte, nativ implementierte Benutzeroberflächenkomponenten - welche im Falle von Flutter sogar auf dem Design System \href{https://material.io/}{\textit{Material Design}} beruht.\\
Das Konzept aus Kapitel \ref{sec:app_concept} schlägt vor, dem Nutzer die Bewertung einzelner Filme über eine Wisch-Funktion bereitzustellen.
Allein dieser Bildschirm muss zunächst einmal eine Reihe von Filmen inklusive Titelbild und Informationen über HTTP Anfragen von unserer Datenbank laden, die Animationen und Logik hinter dem Bewertungssystem abarbeiten und zusätzlich die Bewertung wieder zurück an unseren Server senden.
Aufgrund dieses enorm hohen Performance-Anspruchs sind nativ implementierte Komponente unabdingbar.
Da sowohl Flutter als auch React Native es ermöglichen, die UI Komponenten in der plattformspezifischen Sprache zu implementieren, erweist sich der Leistungsvergleich beider Frameworks als schwierig.
Grundlegend kann jedoch angenommen werden, dass Flutter eher weniger CPU-Nutzung beansprucht, jedoch dazu tendiert, mehr Speicher vor der eigentlichen Anwendung anzufordern\cite{bjorn-hansen2020}

Somit kristallisierten sich drei Entwicklungsmöglichkeiten per Ausschlussverfahren heraus:
\begin{itemize}
	\item Native Anwendung für jeweils Android und iOS
	\item Plattformübergreifend mit Flutter
	\item Plattformübergreifend mit React Native
\end{itemize}

Mit einer nativen Anwendung für jede Plattform erhält man nicht nur doppelten Entwicklungsaufwand, sondern gleichzeitig auch doppelten Wartungsaufwand. 
Zusätzlich gegen die native Möglichkeit spricht, dass für die Entwicklung einer iOS Anwendung die Entwicklungsumgebung XCode benötigt wird, welche eine Desktopanwendung ausschließlich für das Betriebssystem macOS ist.
Daher ist die Entwicklung nicht nur in Sachen Codezeilen ein deutlicher Mehraufwand, welcher sich aber bei der Größe des Projektes nicht bezahlt macht.
Bei den plattformübergreifenden Lösungen entfällt dieser Aspekt, jedoch ist das veröffentlichen einer iOS Anwendung im Vergleich zu Android weiterhin deutlich komplizierter - hierauf wird im weiteren Verlauf der Arbeit noch eingegangen.\\
\\
Beim direkten Vergleich zwischen React Native und Flutter ist der deutlichste Unterschied, dass React Native die Entwicklung einer Laufzeit-basierten Anwendung bietet und Flutter die einer kompilierten Anwendung.
Hierbei werden unterschiedliche Programmiersprachen verwendet: Flutter beruht auf der Google eigenen Sprache Dart. 
Da diese sich bisher noch nicht etablieren konnte, ist diese Sprache unbekannt und muss neu erlernt werden.
JavaScript hingegen ist weit verbreitet, jedoch bringt die spezielle Erweiterung JSX bei React Native ebenfalls zusätzlichen Lernaufwand mit sich.\\
Während der Entwicklung bieten beide Frameworks eine \glqq Hot Reload\grqq Funktion an, welche vor allem bei der Erstellung von Benutzeroberflächen deutliche Zeitersparnisse ermöglicht.
Flutter punktet jedoch vor allem hierbei durch die direkte Unterstützung von UI Bibliotheken, welche React Native ausschließlich über externe Bibliotheken bezieht. 
Gleichzeitig bringt Flutter allgemein mehr \glqq out of the box\grqq mit sich, weshalb bei React Native eher Probleme durch Abhängigkeiten von Drittanbieter entstehen können. \\
\\
Der ausschlaggebende Punkt ist jedoch tatsächlich die BaaS-Plattform (Backend-as-a-Service).
Es existiert zwar ein großer Konkurrent zu Firebase, nämlich \href{https://docs.amplify.aws/}{AWS Amplify}.
Hierbei handelt es sich ebenfalls um ein Backend-Service für Mobil- und Webanwendungen. 
Aufgrund der auf Skalierung ausgesetzten Tools mit besseren Echtzeit-Features ist Firebase jedoch speziell für Nachrichtenaustausch besser geeignet.
Gleichzeitig spielt die Vertrautheit mit dieser BaaS Plattform und die breit gefächerten Tools eine große Rolle bei der Auswahl des Services.
Letztendlich wurde die Entscheidung getroffen, das allgemeines Nutzermanagement und Chat-Funktion der Anwendung mit Firebase zu realisieren.\\
Da AWS Amplify erst seit Beginn 2021 eine offizielle Unterstützung für Flutter anbieten\footnote{\url{https://aws.amazon.com/de/about-aws/whats-new/2021/02/announcing-general-availability-amplify-flutter-data-authentication-support/}}, wurde Flutter als Frontend-Framework und Firebase als BaaS-Plattform ausgewählt.

\subsection{Server}
Der Webserver ist jener Dienst,  der die zugrundeliegenden Funktionalitäten bezüglich der Filmabfragen, der Matching-Logik und der Filmempfehlung bietet. 
Anforderungen an die genutzte Webservertechnologie sind zum einen eine grundlegend hohe Performance, um mit einer hohen Anzahl an Serveranfragen umzugehen. Des Weiteren sollte die Technologie Skalierbarkeit in Bezug auf die Performance und wachsenden Ressourcen wie Hardware aufweisen und eine Unterstützung, Dokumentation und umfassende Funktionalitäten des Frameworks bieten. 
Ein Paketmanager, der umfassende Kern-Funktionalitäten zur Verfügung stellt, sollte vorhanden sein, damit diese nicht neu implementiert werden müssen. Um offen für das genutzte Zielbetriebssystem zu bleiben, sollten mehrere Betriebssysteme unterstützt werden. 
Im folgenden werden keine proprietären Webserver-technologien betrachtet.
\newline
Nach genauerer Recherche kamen drei Webservertechnologien in die engere Betrachtung:

\begin{itemize}
	\item PHP
	\item Django
	\item Node.js
\end{itemize} 

\noindent
Im Hinblick auf die Performance sticht Node.js aufgrund seiner ereignisgesteuerter Architektur  und dem Non-Blocking I/O-Mechanismus heraus und verspricht eine bessere Ressourcennutzung. 
\newline
Große Firmen wie Uber \footnote{siehe \url{https://eng.uber.com/uber-tech-stack-part-two/ }, letzter Zugriff 18.03.2021}, Ebay und Netflix \footnote{siehe \url{https://entwickler.de/online/javascript/7-gruende-node-js-579924149.html}, letzter Zugriff 18.03.2021 } haben ihre Systeme bereits auf Node.js umgestellt. Die Wahl als Webservertechnologie fällt auf Node.js, da es breite Unterstützung erfährt, die auch durch den mächtigen Paketmanager npm ergänzt wird und eine hohe Performance errichtet.


\subsection{Datenbank}
Im Hinblick auf die Speicherung der potenziell hohen Anzahl an Nutzern, deren Swipe-Ent\-schei\-dungen und deren Matches untereinander sowie der Anzahl von über 500.000 Filmen\footnote{siehe \url{https://www.themoviedb.org/faq/general}, letzter Zugriff 18.03.2021} wird ein performanter Umgang der Datenbank mit vielen Datensätzen notwendig sein.  
Um massive Daten speichern zu können sind relationale Datenbanken nicht die passende Wahl. 
Es hat sich gezeigt, dass je größer die Menge an Daten ist und je mehr Tabellen in einer Anfrage enthalten sind, desto größer ist der Performanceverlust durch SQL. \cite{4.5}
\newline
Die Verwendung von dokumentenbasierten Datenbanken führt dagegen zu einer strukturlosen Zusammensetzung an Daten, bei denen ein Dokument ein einzelnes Objekt repräsentieren kann. 
Somit muss für die Wiedergabe eines Objekts nur ein Dokument angefragt werden. Die fehlenden Möglichkeiten zur Normalisierung können jedoch zu Redundanzen in den Daten führen, wodurch die Entwicklung der aufrufenden Anwendung komplexer werden kann. 
Die Redundanz wird jedoch in Kauf genommen, um schnelle Abfragen zu ermöglichen und eine hohe Performance zu erhalten. Da Datensätze in dokumentenbasierten NoSQL-Datenbanken schemalos als JSON-Objekte abgelegt werden, begünstigt dies den generischen Dokumentenaufbau in der Entwicklung.
\newline
Einige NoSQL-Datenbanken wie MongoDB verfolgen einen nicht-relationalen Ansatz und werden mit JavaScript-fähigen Schnittstellen bereitgestellt. Durch die Kommunikation im JSON-Format eignen ist ein optimaler Einsatz mit Node.js gegeben. MongoDB ist über seine horizontale Skalierbarkeit darauf ausgelegt, in einem kurzen Zeitraum sehr viele Daten zu verarbeiten \cite{Tech6}. Während relationale Systeme vertikal im Sinne von neuen Tabelleneinträgen skalieren, werden Dokumente hingegen werden in einer Kollektion, die horizontal erweitert werden können, indem Datenmengen im Sinne des Shardings auf mehreren Systemen verteilt werden, anstatt ein einzelnes System zu verwenden.
\newline
Als Datenbank für die Backend-Implementierung wurde aufgrund von Performance, der guten Einbindung an Node.js und der Skalierbarkeit MongoDB ausgewählt. Um die Vorteile der Da\-ten\-kompression sowie der Transaktionen über mehrere Dokumente hinweg zu nutzen, ist die WiredTiger-Engine die Wahl für das genutzte Storage-Engine.  


\subsection{Kommunikationsschnittstelle}
Als Kommunikationsschnittstelle wird eine WebApi entwickelt, dessen Kommunikation auf HTTP-Nachrichten basiert, deren Informationen im JSON-Format übergeben werden. Diese Technologie bietet eine einfache und dennoch effiziente Form der Kommunikation zwischen Server und Client.

\subsection{Film-Datenbank}
=>TMDb API, https://developers.themoviedb.org/4/getting-started/authorization\newline
OMDb API, http://www.omdbapi.com/\newline
Verschiedene kleinere Anbieter, https://rapidapi.com/search/movie\newline
    vince?
\newline

Github.