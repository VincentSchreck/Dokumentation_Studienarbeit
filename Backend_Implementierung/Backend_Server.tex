Die Serverzuständigkeiten des StreamSwipe-Webservers lassen sich in folgende Aspekte zusammenfassen:
\begin{itemize}
\item Empfangen und Beantworten der Clientanfragen
\item Routing der Anfragen zu den entsprechenden Abhandlungsroutinen
\item Überprüfen der Identität des Clients
\item Kommunikation zur Datenbank für die persistente Speicherung der Zustände der Nutzer und ihrer Präferenzen, Swipes und Matches.
\item Matching-Algorithmus
\end{itemize} 

\noindent
In den folgenden Unterkapiteln wird auf die Einrichtung des Node.js-Webservers und der MongoDB-Datenbank, sowie auf die Erstellung der sicheren Kommunikationsschnittstelle und auf die Implementierung der serverzuständigen Funktionalitäten eingegangen. Der StreamSwipe-Webserver wird im weiteren Text in der Kurzform als Webserver bezeichnet. 

\subsubsection{Bereitstellung des Webservers}
Zunächst wird das Node.js-Installationspaket aus der offiziellen Seite der Hersteller heruntergeladen und ausgeführt, wie in Abbildung \ref{fig:installation_nodejs} dargestellt. Hierbei werden sowohl die Laufzeitumgebung für Node.JS, als auch der npm package manager installiert (siehe nächste Abbildung). 
Zusätzlich wird bei der Installation ausgewählt, dass Node.js sowie npm und dessen Module zu den Umgebungsvariablen hinzugefügt werden. Dabei werden Variablen unter ihrem Applikationsnamen gespeichert und ihre entsprechenden Datei-Pfade hinterlegt.
Über die Benutzung dieser Umgebungsvariablen ist ein schneller Zugriff über ein Terminal beziehungsweise einer anderen Applikation gewährleistet.


\begin{figure}[tbt]
\centering
\includegraphics[width=8cm]{images/nodejs_install.png}
\caption{Node.JS Installation}
\label{fig:installation_nodejs}
\end{figure}

\noindent
Nach der Installation von Node.js (siehe Abbildung \ref{fig:installation_nodejs}) kann das Projekt mithilfe des Befehls \glqq npm init\grqq \, im Terminal initialisiert werden. 
Hier werden nacheinander Input für relevante Projektaspekte wie dem Projektnamen, der Initialversion, der Startprogrammdatei oder dem GIT-Repository abgefragt.  
Im Anschluss wird im aktuellen Verzeichnis eine Datei \glqq package.json\grqq \, erstellt,  bei der es sich um eine Manifest-Datei im JSON-Format handelt, die unter anderem die benötigten Pakete sowie dessen Version, als auch projektspezifische Meta-Informationen wie den Projektnamen, die Projektversion, die Projektbeschreibung und den Autor enthält.
\newline
Im Anschluss an die Initialisierung werden die benötigten Pakete installiert. Dafür wird der Befehl \glqq npm install\grqq \, in Kombination mit dem angeforderten Modul genutzt. 
Nach der ersten Installation eines Moduls wird im Hauptverzeichnis des Projekts automatisch ein Ordner \glqq node\_modules\grqq \, erzeugt. Dieser enthält die Quelldaten der Node.js-Module. 
\newline
Da die Funktionalität, die nodemon bietet, nur in der Entwicklung benötigt wird, wird in der Datei \glqq package.json\grqq \, ein Entwicklungsskript \glqq devStart\grqq \, definiert. 
Skripte erlauben das automatische Starten von anderen Applikationen. Über \glqq npm run\grqq \, in Kombination mit dem auszuführenden Skript wird die Hauptapplikation über die Datei, die im package.json unter \glqq main \grqq \, hinterlegt ist, zusammen mit den Applikationen, welche im package.json unter dem entsprechenden Skript aufgezählt sind, gestartet.
\newline
Als Applikationsstartpunkt wird die Datei \glqq server.js\grqq \, erzeugt und im package.json unter main hinterlegt.\\

\begin{lstlisting}[caption=Datei package.json, label=lst:packagejson]
{
  "name": "StreamSwipeServer",
  "version": "1.0.0",
  "description": "Our Backend-Server for the StreamSwipe Mobile Application",
  "main": "server.js",
  "scripts": {
    "start": "",
    "devStart": "nodemon"
  },
  "author": "Robin Meckler, Vincent Schreck, Leon Gieringer",
  "license": "-",
  "dependencies": {
    "express": "^4.17.1",
    "firebase-admin": "^9.5.0",
    "mongoose": "^5.11.17",
    "node-cron": "^2.0.3",
    "dotenv": "^8.2.0"
  },
  "devDependencies":{
    "nodemon": "^2.0.7"
  }
}
\end{lstlisting}

\subsubsection{Geplante Architektur}
Die Software für den StreamSwipe-Server wird in Komponenten/Module aufgeteilt. Vorteile dieser Modularisierung sind, dass die einzelnen Module schneller verstanden und dementsprechend leichter überarbeitet werden können. Außerdem können Codeduplizierungen vermieden werden und Softwarekomponenten an verschiedenen Punkten im Code wiederverwendet werden. Abbildung \ref{fig:WebserverArchitektur} stellt die Architektur des Webservers dar. Die Route-Komponenten dienen als Empfangsschnittstelle für HTTPS-Anfragen. Die tatsächlichen Abhandlungsroutinen finden in den Controller-Komponenten statt, welche zum Zugriff auf die Datenbank auf die Service-Komponenten zugreifen und die HTTPS-Antworten zurückschicken.
\begin{figure}[tbt]
\centering

\includegraphics[width=13cm]{images/backendstruktur.PNG}
\caption{Webserver Architektur}
\label{fig:WebserverArchitektur}
\end{figure}

\subsubsection{Sichere Kommunikation}
\label{sec:SichereKommunikation}
Das http-Modul ermöglicht eine Kommunikation über das http-Protokoll.\\
 
\begin{lstlisting}[caption=Einfache Verbindung, label=lst:nodejs_easyconnection]
{
 const app = express();
 app.use(express.json()); 
 var httpServer = http.createServer(app);
 httpServer.listen(process.env.HTTP_PORT, () => 
 console.log("HTTP-Server started on " + process.env.HTTP_PORT));
}
\end{lstlisting}

\noindent
Dabei werden jedoch die Daten unverschlüsselt versendet. Um ausreichend Datenschutz zu gewährleisten, wird stattdessen das https-modul genutzt\footnote{Siehe Dokumentation: \url{https://nodejs.org/api/https.html}, letzter Zugriff: 24. April 2021}.
\newline
Benötigt für einen HTTPS-Server werden ein Sicherheitszertifikat und ein privater Schlüssel, die zunächst mithilfe des Tools OpenSSL erzeugt werden.  
Dabei ist zu beachten, dass während der Entwicklungsphase das Zertifikat nicht von einer zuständigen Zertfikatsstelle signiert wurde und somit von anderen Gegenstellen nicht akzeptiert wird.
\newline
In der Anwendung wird zunächst ein Objekt 'httpsOptions' erzeugt, das unter dem Attribut 'cert' das generierte Sicherheitszertifikat und unter dem Attribut 'key' den privaten Schlüssel enthält. Anschließend wird über die Funktion 'createServer' des https-Objekts der https-Server gestartet, woraufhin ein Objekt vom Typ https.Server zurückgegeben wird\footnote{Siehe Dokumentation:  \url{[https://nodejs.org/api/https.html\#https_class_https_server]}, letzter Zugriff: 24. April 2021}. 
Diesem Serverobjekt wird über seine Methode 'listen' aufgefordet, auf eingehende Nachrichten in dem als Parameter übergebenen Port einzugehen.\\

\begin{lstlisting}[caption=Gesicherte Verbindung, label=lst:nodejs_safeconnection]
{
 ...
 const https = require("https");
 const httpsOptions = {
  cert: fs.readFileSync('sslcert/server.crt', 'utf8'),
  key: fs.readFileSync('sslcert/server.key', 'utf8')
 }
 var httpsServer = https.createServer(httpsOptions, app);
 httpsServer.listen(process.env.HTTPS_PORT, () => {console.log("HTTPS - 	Server started on " + process.env.HTTPS_PORT)});
}
\end{lstlisting}


\subsubsection{Datenbankverbindung}
Wie bereits erwähnt, wird das Modul „mongoose“ für die Verbindung mit der MongoDB-Datenbank verwendet, wie im Beispiel \ref{lst:mongodbconnection} dargestellt.
Da der Quellcode in anderen Dateien hinterlegt ist, muss für den Zugriff auf dessen Funktionalitäten das entsprechende Modul zunächst inkludiert werden. Dazu wird die require-Methode aufgerufen, die ein Objekt zurückgibt, dass die aus dem Modul exportierten Methoden enthält und im Folgenden als Variabel mit dem Namen „mongoose“ gespeichert wird. 
\newline
Über die connect-Methode des zurückgelieferten Objekts wird nun bei Parameterübergabe der Datenbank-URL versucht, eine Verbindung aufzubauen.  
Dabei wird unter der Objekt-Membervariable  „connection“ ein Objekt vom Typ „Connection“ hinterlegt, über das bei erfolgreicher Verbindung mit der Datenbank kommuniziert werden kann und das nachfolgend unter der Variable „database“ abgespeichert ist.\\

\begin{lstlisting}[caption=Verbindung zur MongoDB-Datenbank, label=lst:mongodbconnection]
{
 const mongoose = require('mongoose');
 let database = null;

 async function startDatabase() {
  await mongoose.connect(process.env.DATABASE_URL, 
   {useNewUrlParser: true,
   useUnifiedTopology: true}); 
  database = mongoose.connection;
  database.on('error',(error) => console.log(error));
  	database.on('open',(error) => console.log('Connected to DB'))}

 async function getDatabase() {
 if (!mongoose.connection) await startDatabase();
  return database; }

 module.exports = {
  getDatabase,
  startDatabase }
}
\end{lstlisting}

%\subsection{Datenbank}
\input{Backend_Implementierung/Backend_Serverkomponenten/Backend_Server_Models.tex}

\subsubsection{Datenbankzugriff}                   
\input{Backend_Implementierung/Backend_Serverkomponenten/Backend_Server_Services.tex}

\subsubsection{Controller} 
\input{Backend_Implementierung/Backend_Serverkomponenten/Backend_Server_Controller.tex}


\subsubsection{Routing} 
\input{Backend_Implementierung/Backend_Serverkomponenten/Backend_Server_Routes.tex}

\subsubsection{Weitere Backendfunktionalit"aten} 
\input{Backend_Implementierung/Backend_Serverkomponenten/Backend_Server_Weitere.tex}

