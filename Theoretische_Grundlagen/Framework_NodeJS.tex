Im Jahr 2009 veröffentlichte Ryan Dahl das Framework Node.js, das auf Googles V8-Engine, welche auch als JavaScript-Engine in Googles Browser Chrome zum Einsatz kommt, basiert und sich hervorragend für hochperformante, skalierbare und schnelle Webanwendungen eignet. Zudem ermöglicht es Webentwicklern die Entwicklung von serverseitigem JavaScript-Code\footnote{\url{https://v8.dev/}, letzter Zugriff: 03.April 2021}.


\subsubsection{Architektur}
Eine wesentliche Eigenschaft von Node.js ist die hohe Performance. Im Folgenden soll der Unterschied der Node.js-Architektur zu traditionellen Webservern und der damit verbundenen höheren Performance dargestellt werden.
\newline

\noindent
Herkömmliche Webserver erstellten zunächst für jede ankommende Anfrage einen neuen Thread. Dieses Vorgehen ist eng mit steigendem Speicher- und Rechenaufwand verbunden. Um sich Rechenzeit, die durch die Erstellung und Zerstörung von Threads entstanden, zu sparen, wurden Threadpools eingerichtet. Dieser Threadpool enthält mehrere Threads, denen Aufgaben zugewiesen werden können. Nach erfolgreicher Abarbeitung einer Operation kann einem Thread eine weitere Aufgabe zugeordnet werden.
\newline

\noindent
Es bleibt aber ein weiteres Problem: Bei der Anfragenabarbeitung kann es zu einer Form von blockierender Ein- und Ausgabe (Blocking Input/Output kurz Blocking I/O) kommen: zum Beispiel beim Suchen in einer Datenbank oder dem Laden einer Datei im Dateisystem.
 Während der Abarbeitung wartet der Thread solange, bis die Operation ein Ergebnis zurückwirft und belegt dabei weiterhin Speicherplatz. 
 Bei hohem Aufkommen von Anfragen kommt es dadurch zu einer hohen Speicherauslastung des Servers. Zudem kosten die Kontextwechsel zwischen den Threads im Betriebssystem weitere Rechenzeit \cite{Node1.05}. Man spricht bei diesem Architekturkonzept auch vom Multi-Threaded Server.
\newline

\begin{figure}[h]
\centering
\includegraphics[width=10cm, height = 5.5cm]{images/nodejs_otherthreading.png}
\caption{Multithreaded / Blocking I/O \cite{Node1.1}}
\end{figure}
 
\newpage

\noindent
Node.js verfolgt einen anderen Ansatz: Anfragen werden nur in einem einzigen Thread, dem Hauptthread, abgearbeitet und in einer Warteschlange verwaltet. Dadurch bleiben Kontextwechsel zwischen Threads erspart. Hierbei handelt es sich also um einen Single-Threaded Server. Der Hauptthread verwaltet eine Schleife, die sogenannte Event Loop, die permanent Anfragen aus der Event-Warteschlange überprüft und Ereignisse, die von Ein- und Ausgangsoperationen ausgerufen werden, verarbeitet.
\newline

\noindent
Bei Ankommen einer Nutzeranfrage an einen Node.js Server wird zunächst in der Event Loop geprüft, ob diese Anfrage Blocking I/O benötigt. Falls nicht, kann die Anfrage direkt bearbeitet werden und die Antwort an den Nutzer zurückgesendet werden. 
\newline

\noindent
Im anderen Fall wird einer von Node.js interner Workern, welche prinzipiell auch Threads sind, aufgerufen, um die jeweilige Operation auszuführen. Dabei wird eine Callback-Funktion mitgegeben, die vom Worker aufgerufen wird, sobald die Operation ausgeführt wurde. Diese Callback-Funktion kann anschließend als Ereignis von der Event Loop registriert werden. Man spricht hierbei auch von ereignisgesteuerter Architektur. [1.4]
\newline
 
\begin{figure}[h]
\centering
\includegraphics[width=10cm, height = 5.5cm]{images/nodejs_nodethreading.png}
\caption{Single Threaded / Non Blocking I/0 \cite{Node1.1}}
\end{figure}
 

\noindent
Der große Vorteil hierbei ist, dass der Hauptthread trotz der blockierenden Ein- und Aus\-gabeoperationen nicht anhält, und weitere Anfragen bearbeiten kann. (Non Blocking I/O - Prinzip) 
\newline

\newpage
\subsubsection{Module}

\noindent
Module stellen in Node.js Software-Komponenten dar, die Objekte und Funktionen nach außen hin bereitstellen sollen.
Sie können aus einer Skriptdatei oder einem Verzeichnis von Dateien bestehen. Module können als einzelne Default-Komponenten, die den Hauptteil des Moduls repräsentiert, exportiert werden. 
Bei der anderen Möglichkeit, des sogenannten ‚benannten Exports‘ werden die zu exportierenden Komponenten dagegen explizit angegeben. Letzteres ist in nachfolgender Abbildung dargestellt. 
\newline
  
    
\begin{lstlisting}[caption=Benannter Export von Modulen,label=lst:ModuleExport]
function foo(){}
function bar(){}

//Obige Funktionen exportieren:
module.exports.foo = foo;
module.exports.bar = bar;
\end{lstlisting}


\noindent
Für den Import stehen verschiedene Möglichkeiten zur Verfügung.
Im folgender Abbildung ist ein Import über die require()-Funktion dargestellt. 
Mit mitgeliefertem Modul-Pfad als Parameter gibt diese Funktion ein Objekt des Moduls wieder, das die exportierten Objekte (und Funktionen) enthält.
\newline
  
\begin{lstlisting}[caption=Import von Modulen,label=lst:ModuleImport]
//Importieren der Funktion einer anderen Datei:
const foo = require('./module/path');
const bar = require('./module/path');
\end{lstlisting}

\noindent
Eine wichtige Besonderheit ist, dass importierte Module  beim ersten Aufruf gecached werden. 
Das bedeutet, dass jeder require()-Aufruf auf ein Modul dasselbe Objekt zurückliefert \cite{Node1.21}.


\paragraph{npm}
Ehemals als Node Package Manager bekannt, ist npm ein Paketmanager für Node.js, entwickelt 2010 von Isaac Z. Schlueter \cite{Node1.3}. Es verwaltet ein öffentliches Repository (ein digitales Software-Verzeichnis im Internet) unter dem Name npm Registry. In dem Verzeichnis werden weit über 1 Millionen Pakete (Module) angeboten \cite{Node1.4}. Der Großteil kann unter freier Lizenz verwendet werden. Mit npm können Module installiert, aktualisiert, entfernt und gesucht werden. Node.js liefert seit seiner Version 0.6.3 npm standardmäßig bei der Installation mit \cite{Node1.5}.

\paragraph{Express}
„Express ist ein einfaches und flexibles Node.js-Framework von Webanwendungen, das zahlreiche leistungsfähige Features und Funktionen für Webanwendungen und mobile Anwendungen bereitstellt“\cite{Node1.6}.  Es wurde im November 2010 von Douglas Christopher Wilson und weiteren Entwicklern veröffentlicht und erweitert Node.js um das Abarbeiten verschiedener HTTP-Methoden, das separate Abarbeiten von Anfragen mit verschiedenen URL-Pfaden sowie weiterer nützlicher Möglichkeiten. Im Grunde handelt es sich bei Express um ein Modul, dass durch den npm Package Manager heruntergeladen werden kann. Die aktuelle Version zum Zeitpunkt der Dokumentation [??TODO] ist 4.17.1 \footnote{\url{https://www.npmjs.com/package/express}, letzter Zugriff 04.04.2021}
\newline
\newline
\textbf{Beispiel}
 \newline

\noindent
Das Erstellen einer einfachen Express-Applikation wird im folgenden Beispiel dargestellt:\newline

\begin{lstlisting}[caption=Einfacher Webserver [nodejs 1.8],label=lst:Middleware]
const express = require('express');
const app = express();
const port = 3000;

app.get('/', (req,res)=> {
	res.send('Hello World')
});

app.listen(port, () => {
	console.log("Example app listening on port ${port}!")
});
\end{lstlisting}

\noindent
Die require()-Funktion importiert das Express-Modul und gibt ein Express-Objekt zurück. 
Dieses Objekt als Funktion aufgerufen gibt wiederum ein Objekt der Express-Applikation zurück, welche traditionell „app“ genannt wird, das Kernstück des Express-Frameworks ist und sämtliche Methoden wie das Weiterleiten von HTTP Anfragen, das Konfigurieren von Middleware oder das Modifizieren des Webserver-Verhaltens beinhaltet \cite{Node1.8}.
\newline
\noindent
Im mittleren Block befindet sich eine Routendefinition. Die app.get() Funktion spezifiziert eine Callback-Funktion, die ein „request“- und „response“-Objekt als Parameter erhält und aufgerufen wird, sobald eine HTTP Anfrage der Methode GET mit dem Pfad ‚/‘ empfangen wird. Das Request-Objekt enthält sämtliche Informationen über die HTTP-Anfrage. Das Response-Objekt kann dagegen in der Callback-Funktion mit Informationen gefüllt werden und über die send()-Funktion als HTTP-Antwort an den Sender zurückgesendet werden.
\newline
\noindent
Der unterste Block startet den Webserver auf dem mitgegebenen Port über die Funktion app.listen(). Ihr kann auch eine Callback-Funktion mitgegeben werden, die aufgerufen wird, sobald der Server erfolgreich gestartet ist.
\newpage
\noindent
\subparagraph{Middleware}
Express arbeitet nach dem Middleware-Konzept. Darunter versteht man Funktionen, die für die Verarbeitung von Anfragen hintereinandergeschaltet werden können. Jede Middleware hat Zugriff auf das Anfrageobjekt, das Antwortobjekt und die jeweils nächste Middleware-Funktion \cite{Node1.9}.
Dabei kann die HTTP-Request direkt terminiert oder an die nächste Middleware gesendet werden. Die Verkettung der Middleware-Funktionen wird in folgender Abbildung illustriert:
\newline

\begin{figure}[h]
\centering
\includegraphics[width=12cm]{images/nodejs_middleware.png}
\caption{Middleware \cite{Node1.2}}
\end{figure}

%
%       Middleware
%			express.json
%

\noindent
\subparagraph{Middleware: express.json}

\noindent
Hierbei handelt es sich um eine in express eingebaute Middleware, die die in JSON formatierten Daten im Nachrichtenrumpf aus einer eingehenden HTTP-Anfrage grammatisch analysiert.  Dabei ist zu beachten, dass der Nachrichtenrumpf nur dann analysiert wird, wenn bei der Anfrage eine Header-Informationen namens „Content-Type“ mit dem entsprechenden JSON-Typ als Wert übergeben wird. Nach erfolgreicher Analyse erstellt die Middleware aus den JSON-Informationen eine neues body-Objekt innerhalb des übergebenen request-Objekts. [nodejs 2.1]
\newline

\begin{lstlisting}[caption=Express.json Middleware benutzen,label=lst:ExpressNutzen]
const express = require('express');
const app = express();
app.use(express.json());
\end{lstlisting}

%
%       Middleware
%			Router
%

\newpage
\noindent
\subparagraph{Middleware: Router}

\noindent
Unter dem Begriff Routing (Weiterleitung) versteht man im Kontext von Express „[...] die Definition von Anwendungsendpunkten (URIs) und deren Antworten auf Clientanforderungen.“ [nodejs 2.15]
\newline

\noindent
Die in express eingebaute Middleware express.Router ermöglicht es, modular einbindbare Routenhandler (Weiterleitungsroutinen) zu erstellen. Eine Router-Instanz ist als vollständiges Middleware- und Routingsystem zu sehen und wird deshalb auch als „Mini-App“ angesehen. Der sich durch die Modularität herausziehende Vorteil ist, dass folglich unterschiedliche Anwendungsendpunkte auf entsprechende Dateien ausgelagert werden können.
\newline



\begin{lstlisting}[caption=Routinghandler erstellen \protect \footnotemark,label=lst:RoutingHandlerCreate]
var express = require('express');
var router = express.router();

// Middleware explizit fuer diesen Router
router.use(function timeLog(req,res,next) {
	console.log('Time: ', Date.now());
	next();
});

// Homepage Route - Abhandlung
router.get('/', function(req,req){
	res.send('Birds home page');
});

// About Route - Abhandlung
router.get('/about', function(req,req){
	res.send('About birds');
});
module.exports = router;
\end{lstlisting}
\footnotetext{Express, API-Dokumentation Router. \url{https://expressjs.com/en/api.html\#router}, letzter Zugriff: 05.April 2021}

\noindent
In oberem Beispiel wird ein Routerhandler für das Verzeichnis ‚/birds‘ mit eigen implementierter Middleware und zwei Anwendungsendpunkte ‚/‘ (bezieht sich auf das Stammverzeichnis) und ‚/about‘ erstellt. Der Code wird unter der Datei birds.js abgespeichert. 
Abschließend kann das Routermodul in die Anwendung geladen werden: 
\newline

\begin{lstlisting}[caption=Routinghandler benutzen,label=lst:RoutingHandlerUsage]
var birds = require('./birds');
..
app.use('birds', birds);
\end{lstlisting}

%
%       Mongoose
%
%

\newpage
\paragraph{Mongoose}
Mongoose ist ein öffentliches Modul, das zum Zeitpunkt der Dokumentation[TODO??] im npm Package Manager in der Version 5.12.3 zur Verfügung steht \footnote{npm mongoose. \url{https://www.npmjs.com/package/mongoose}, letzter Zugriff: 05.April 2021}. Bei diesem Modul handelt es sich um ein Object-Document Mapper (ODM), der es ermöglicht, asynchron mit einer NoSql-Datenbank zu kommunizieren. Mongoose ist der populärste und am weitest von MongoDB unterstützte ODM \cite{Node2.55}. Es unterstützt neben transparenter Persistenz auch die Datenvalidierung, das Erstellen von Abfragen (Queries), das Schreiben von logischem Business Code und die Übertragung zwischen Objektem im Code und der Repräsentierung dieser Objekte in der Datenbank.
\newline

%
%       ODM
%
%

\noindent
\subparagraph{Object Document Mapping (ODM)}
Object-Relational Mappers (ORM) finden haupt\-sächlich Einsatz in objektorientieren Anwendungen, dessen Daten in relationalen Datenbanken sind. Dabei werden die Tabellen in persistente Objekte gemappt.
Das Mappen ist aber auch für NoSQL-Datenbanken nützlich \cite{Node2.56}. Die meistverbreiteten NoSQL-Datenbanken basieren auf Dokument-Systemen. Dementsprechend werden für diese Datenbanken Object-Document Mapper für das Mappen zwischen Dokumenten und Objekten genutzt. Einige ODM’s sind Mongoose\footnote{Mongoose Webpage, \url{http://mongoosejs.com}, letzter Zugriff 04.04.2021}, Morphia\footnote{Morphia Webpage, \url{https://github.com/mongodb/morphia}, letzter Zugriff 04.04.2021}, Doctrine \footnote{Doctrine Project Webpage, \url{http://www.doctrine-project.org/}, letzter Zugriff 04.04.2021} und Mandango\footnote{Mandango Webpage, \url{https://mandango.readthedocs.io/en/latest/}, letzter Zugriff 04.04.2021.}
NoSQL Mapper nutzen vom Entwickler definierte Datenschemata, die das Objekt beschreiben. Ein daraus abgeleitetes Model-Objekt ermöglicht dann die Kommunikation zwischen dem im Schema beschriebenen Objekt und der entsprechenden Datenbank-Collection.
\newline

%
%       Schema
%
%

\noindent
\subparagraph{Schema}
Mongoose-Schemata definieren die Struktur der gespeicherten Daten einer Mongo"-DB-"-Collection in der Anwendungsschicht und werden in der JSON-Notation beschrieben. Dokumentenbasierte Datenbanken wie MongoDB enthalten für jede Wurzelentität eine Collection. Mongoose Schemata werden für jede Collection definiert. Innerhalb der JSON-notierten Schemabeschreibung können den einzelnen Eigenschaften bestimmtes Verhalten zugeordnet werden. Zum Beispiel lässt sich explizit der Datentyp angeben (type), eine Eigenschaft verpflichtend (required) oder in Kleinbuchstaben einstellen (lowercase).
\newline


\begin{lstlisting}[caption=Mongoose Schema - Beispiel,label=lst:MongooseSchema]
const schema = new Schema({
 attributeX: {
 	type: String,  // Datentyp
 	required: true,  // Verpflichtendes Attribut?
 	lowercase: true; // Kleinbuchstaben?
});
\end{lstlisting}

%
%       Model
%
%

\newpage
\noindent
\subparagraph{Model}
Ein Model in Mongoose ist ein aus einer Schemadefinition erstellter Konstruktor, aus denen Objekte instanziiert werden können. Diese Instanzen werden auch ‚documents‘ genannt. Sie stehen in direkter Verbindung zu den jeweiligen Collections der verbundenen Datenbank und enthalten Methoden für die persistente Speicherung, Bearbeitung oder Löschung. Beispielsweise wird beim Abspeichern einer Mongoose Instanz eines Models die entsprechende Collection in der Datenbank erzeugt, sofern sie noch nicht vorhanden ist. Eine Konvention in Mongoose sieht vor, dass der Name eines Models dem Singular eines Nomens entspricht, während die Collections nach dem Plural dieses Namens beschrieben werden \cite{Node3.2}. Im folgenden Beispiel wird ein Model über die mongoose.model()-Funktion erstellt unter Angabe des Modelnamens und dem zu verwendenden Schema. Dieses Model wird über module.exports nach außen zur Verfügung gestellt.

\begin{lstlisting}[caption=Model erstellen und exportierenn,label=lst:MongooseObjectExport]
const mongoose = require('mongoose');
const testSchema = new mongoose.Schema({
	attributeX: {
		type:String,
		required:true,
		lowercase: true
	}
});
module.exports = mongoose.model('test',testSchema);
\end{lstlisting}

\noindent
An anderer Stelle kann das Model nun importiert werden. Aus dem Model kann ein Objekt instanziiert werden, welches über die save()-Funktion in der Datenbank gespeichert werden kann.

\begin{lstlisting}[caption=Model importieren - Objekt instanziieren und persistent speichern,label=lst:MongooseObjectInstance]
const testModel = require(test);

var testInstanz = new testModel();
await testInstanz.save();
\end{lstlisting}

\noindent
Mongoose Models enthalten ohne Instanziierung des Weiteren auch Schnittstellen, um Daten der zugehörigen Collection zu kreieren, abfragen, bearbeiten oder löschen. (Create, Receive, Update, Delete oder auch kurz CRUD).
\newline


\begin{lstlisting}[caption=CRUD-Beispielfunktionen eines Mongoose-Models,label=lst:MongooseCrud]
const testModel = require(test);

//Create
testModel.Insert({attributeX: "abc"})
//Receive
var testObjects = await testModel.find();
var testObject = await testModel.findOne({attributeX: "abc"})
//Update
await testModel.updateONe({X:"abc"},{X: "cba"});
//Delete
await testModel.deleteMany({X:"abc"})
\end{lstlisting}

\newpage
\noindent
\subparagraph{Verbindung}
Verbindung zur Datenbank kann über die connect()-Funktion mit Angabe der genutzten Datenbank und des Datenbankpfads hergestellt werden. 
Über das mongoose.connection-Objekt können auf Verbindungsereignisse reagiert werden. 
\newline

\begin{lstlisting}[caption=Mongoose: Verbindung zur Datenbank aufbauen,
label=lst:MongooseConnect]
const mongoose = require('mongoose');
await mongoose.connect("mongodb://127.0.0.1:27017/TestDB");
mongooose.connection.on('error',(error) => console.log(error));
mongooose.connection.on('open',() => console.log('Connected'));
\end{lstlisting}

\noindent
Für den Verbindungsaufbau können weitere Option übergeben werden. Dafür kann ein Objekt wie in folgendem Beispiel erstellt werden, dass die zugehörigen Optionen als Attribute beinhaltet. 
\newline

\begin{lstlisting}[caption=Mongoose Verbindungsoptionen \protect \footnotemark  ,label=lst:MongooseConnect]
const options = {
	useNewUrlParser: true,
	useUnifiedTopology: true,
	useCreateIndex: true,
	useFindAndModify: false,
	autoIndex: false,
	poolSize: 10, // Anzahl der max. Socket Connections
	serverSelectionTimeoutMS: 5000, // TimeOut bis verbunden
	socketTimeoutMS: 45000, // Schliesse Socket bei 45s                 
	                        // Inaktivitaet
	family:4 // Use IPv4
}
\end{lstlisting}
\footnotetext{Mongoose Connections, \url{https://mongoosejs.com/docs/connections.html}, letzter Zugriff: 05.April 2021}


\paragraph{Weitere Module}

\begin{table}[tbt]
\caption{Module}
\begin{center}
    \begin{tabular}{| l | p{8cm} |}
    \hline
    Express-Modul & Beschreibung \\ \hline
    fs & Erlaubt die Interaktion mit dem Dateisystem.\newline
	Zum Beispiel Schreiben/Lesen von Dateien.\\
    
    \hline
    http & Ermöglicht Datentransfer über das Protokol HTTP und das Abhören eines Ports.  \\
    
    \hline
	https & Gesicherte Variante zu HTTP mit SSL.\newline
	Benötigt Private Key und Zertifikat.  \\
	
    \hline    
    firebase-admin & Ermöglicht die Verbindung zu Google Firebase 			Cloud. \\ 
    
    \hline    
    node-cron & Ermöglicht das Einstellen von sich wiederholenden 			Aufgaben zu bestimmten Zeitintervallen.  \\
    \hline
    \end{tabular}
\end{center}
\end{table}
